---
title: "Tarea 4: Estadística de Áreas"
author: "Pedro Montenegro"
date: "23/11/2019"
mainfont: DejaVu Sans
output:
  html_document: default
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE)
```

```{r, include=FALSE}
library(maptools)
library(spdep)
library(leaflet)
library(RColorBrewer)
library(pander)
library(knitr)
library(skimr)
library(leaflet)
library(tidyr)
library(broom)
library(kableExtra)
library(dplyr)
```


# 1 Introducción

<div style="text-align:justify">
El tutorial fue preparado para los estudiantes graduados en la novena cumbre de Midwest sobre economía aplicada, regional y estudios urbanos (AERUS) en Abril 23-24 de 2016 para la Universidad de Illinois en Champaign urbana.
</div>

<div style="text-align:justify">
Estas notas ilustran el uso de r en análisis econometrico espacial. La teoría es basada en Anselin y Bera (1998) y Arbia (2014) y los aspectos prácticos son actualización de versión de Anselin (2003), con algunos adiciones en visualización espacial para datos r.
</div>

<div style="text-align:justify">
Comentarios y sugerencias son siempre bienvenidas y se pueden enviar a srmntbr2@illinois.edu1.
</div>


# 2 ¿Qué es r y por qué usalo?

<div style="text-align:justify">
R es un software libre, código abierto, y lenguaje orientado a objetos. Libre y código abierto significa que cualquiera puede usarlo, redistribuir y cambiar el software de cualquier forma. Sin embargo, "R es un sofware libre con entorno computacional estadístico y gráficos. Esto compila y corre una amplia variedad de plataformas UNIX, windows y MacOS." [Aquí](http://cran.r-project.org)
</div>


<div style="text-align:justify">
Existen muchos software externos que hacen el análisis de datos bonitos y parecen más fáciles que r, entonces porque debería invertir en apreder sobre R?. Existen en mi opinión al menos tres caracteristicas que R hacen que r valga la pena aprenderlo. Primero que todo, es gratis. Muchos software hoy en día son caros, pero r es gratis y siempre lo será. R también es un lenguaje, lo que significa que no solo puedes usar funciones que estén construidas en el software, sino que también puedes crear tus propias funciones  (para conocer el poder del lenguaje R puede echar un vistazo al Paquete de Regresión Cuantil del Profesor Koenker). La última razón es que R está extremadamente bien soportado. Si tiene una pregunta solamente puede buscarla en Google, publicarla en StackOverflow o usar R-blogger. Si aún no está convencido, simplemente puede escribir "por qué usar el lenguaje R" en Google y creo que los resultados hablarán por sí mismos.
</div>

<div style="text-align:justify">
Todas estas características más el hecho de que los investigadores en la frontera de la profesión usan R como parte de su investigación hace de R una gran herramienta para el análisis de datos espaciales.
</div>

# 3 Introducción al análisis espacial en R

## 3.1 Motivación para el uso de análisis espacial 

<div style="text-align:justify">
Probablemente el argumento más importante a tomar en un enfoque espacial es el supuesto de independencia entre observaciones ya no es válido. Atributos de observación $i$ pueden influir en los atributos de observación $j$.
</div>

<div style="text-align:justify">
Para ilustrar un conjunto de datos muy pequeño de lo que se puede lograr en R para el análisis espacial, nuestro ejemplo examinará crímenes violentas y ejecuciones hipotecarias en la ciudad de Chicago. Los datos de delitos, así como tractos de los archivos shapefile usados aquí provienen del Portal de Datos de Chicago, mientras que los datos de ejecuciones hipotecarias provienen del Departamento de Vivienda y Desarrollo Urbano de los EE.UU (HUD), estos están disponibles al público.
</div>

## 3.2 Paquetes de R para el análisis de datos espaciales.

<div style="text-align:justify">
En R, la unidad fundamental de compartie código es el paquete (package). Un paquete agrupa código, datos, documentación, pruebas y es fácil de compartir con otros. A partir de abril de 2016, había más de 8,200 paquetes disponibles en la Red de Archivos R, conocida como **CRAN**, la repositorio público  para paquetes R. Esta gran variedad de paquetes es una de las razones por las que R tiene tanto éxito: lo más probable es que alguien ya haya resuelto un problema en el que estás trabajando, y puedes beneficiarte de su trabajo descargando su paquete. (Wickham (2015))
</div>

<div style="text-align:justify">
Hoy nos enfocamos en tres paquetes **maptools** (R. Bivand y Lewin Koh (2016)), **spdep** (R. Bivand y Piras (2015), R. Bivand, Hauke y Kossowski (2013)) y **leaflet** (Cheng y Xie (2015)) y un cuarto, el paquete **RColorBrewer** (Neuwirth (2014)) para hacer nuestros gráficos más atractivas. 
</div>

## 3.3 Leyendo y Gráficando datos espaciales en R.

<div style="text-align:justify">
Los datos espaciales vienen en muchas "formas" y "tamaños", los tipos más comunes de datos espaciales son:
</div>

<div style="text-align:justify">
Los puntos son la forma más básica de datos espaciales. Denota una ubicación de un solo punto, como ciudades, una lectura de GPS o cualquier otro objeto discreto definido en el espacio.
</div>

<div style="text-align:justify">
Las líneas son un conjunto de puntos ordenados, conectados por segmentos de línea recta. Los polígonos denotan un área, y pueden pensarse como una secuencia de puntos conectados, donde el primer punto es el mismo que la última Cuadrícula (Ráster) es una colección de puntos o rectangular células, organizadas en una red regular
</div>

<div style="text-align:justify">
Para más detalles, ver R. S. Bivand, Pebesma y Gomez-Rubio (2008). Hoy nos centraremos en los polígonos. Los datos espaciales generalmente vienen en forma de archivo. Este tipo de archivos almacena información de geometría y atributos no topológicos para las características espaciales en un conjunto de datos.
</div>

<div style="text-align:justify">
Además, no requieren mucho espacio en disco y son fáciles de leer y escribir. (ESRI (1998))
</div>

<div style="text-align:justify">
Primero tenemos que descargar y guardar los archivos en nuestra computadora desde nuestro servidor en [Ejecuciones Hipotecarias](http://www.econ.uiuc.edu/~lab/workshop/foreclosures/). Guardé en Mi Escritorio.
</div>

+ **Archivo principal:** foreclosures.shp
+ **Archivo de índice:** foreclosures.shx
+ **Tabla + dBASE:** ejecuciones hipotecarias.dbf

<div style="text-align:justify">
El archivo principal describe una forma con una lista de sus vértices. En el archivo de índice, cada registro contiene el desplazamiento del registro del archivo principal correspondiente desde el comienzo del archivo principal. La tabla dBASE contiene atributos de características con un registro por característica. (ESRI (1998))
</div>

<div style="text-align:justify">
Para leer datos de un archivo de forma de polígono en R, utilizamos la función **readShapePoly()** que creará un objeto SpatialPolygonsDataFrame. Para obtener más información sobre la función, el comando ?ReadShapePoly le dará acceso al archivo de ayuda.
</div>

<div style="text-align:justify">
Pero antes de leer en el shapefile primero configuramos nuestro directorio de trabajo. R siempre apunta a un directorio en su computadora, para encontrar cuál usa **getwd()** (obtener el directorio de trabajo).
</div>

<div style="text-align:justify">
En Windows puede que tenga que usar \. La carpeta de ejecuciones hipotecarias contiene los archivos de forma que descargué antes. Ahora estamos listos para leer en nuestro shapefile.
</div>

```{r}
chi.poly <- readShapePoly('foreclosures.shp')
```

<div style="text-align:justify">
El archivo shapefile ahora lee y almacena en un objeto llamado $chi.poly$. Para verificar que es un SpatialPolygonsDataFrame, podemos usar la función **class()**
</div>

```{r}
tidy(class(chi.poly)) %>%
  rename("Objeto"= "x") %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  
```

<div style="text-align:justify">
Un objeto SpatialPolygonsDataFrame reúne las representaciones espaciales de los polígonos con datos. Las etiquetas de identificación de los polígonos en la ranura coinciden con los nombres de fila del marco de datos para asegurarse de que las filas de datos correctas estén asociadas con el objeto espacial correcto. (R. S. Bivand, Pebesma y Gómez-Rubio (2008))
</div>

<div style="text-align:justify">
Este objeto tiene cuatro partes o ranuras: la primera es la ranura de datos que contiene las variables que se utilizarán para nuestro análisis; el segundo es la ranura del polígono y contiene la información shapefile. El tercer espacio, bbox, es el cuadro delimitador dibujado alrededor de los límites y el cuarto espacio es la cadena proj4 que contiene las proyecciones. Para acceder a la ranura de datos podemos usar la función de ranura o el símbolo @. Para una apariencia compacta de la ranura de datos, podemos usar la función str:
</div>

```{r}
str(slot(chi.poly,"data"))
```

<div style="text-align:justify">
La primera parte es la parte marco de datos que contiene los datos para nuestro análisis. Podemos ver las variables contenidas en la porción de datos del archivo, incluyendo:
</div>

+ **est_fcs:** el recuento estimado de ejecuciones hipotecarias comienza desde enero de 2007 hasta junio de 2008
+ **est_mtgs:** número estimado de hipotecas activas desde enero de 2007 hasta junio de 2008
+ **est_fcs_rt:** número de ejecuciones hipotecarias iniciadas dividido por número de hipotecas multiplicado por 100
+ **bls_unemp:** lugar de junio de 2008 o tasa de desempleo del condado
+ **totpop:** población total del Censo 2000
+ **violento:** número de delitos violentos denunciados entre enero de 2007 y diciembre de 2008
+ **propiedad:** número de delitos contra la propiedad denunciados entre enero de 2007 y diciembre de 2008

<div style="text-align:justify">
También podemos obtener estadísticas resumen de las variables de interés utilizando el resumen de funciones. Por ejemplo:
</div>

```{r}
tidy(summary(chi.poly@data$violent)) %>%
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Estadísticas Resumen" = 6))
```


<div style="text-align:justify">
Aquí accedimos a la porción de datos del shapefile con el signo @ y luego a la variable con el signo $. Para ver las otras ranuras, podemos proceder de la misma manera.
</div>

<div style="text-align:justify">
Una buena característica de la clase de objetos espaciales es que podemos usar las características de gráficos tradicionales de R. El siguiente comando nos proporciona un gráfico de las secciones censales de Chicago:
</div>


```{r}
plot(chi.poly,main="Secciones censales de Chicago")
```

<div style="text-align:justify">
pero podemos ir un paso más allá y hacer mejores parcelas usando el paquete de folleto. Esto genera un mapa interactivo que se puede representar en páginas HTML.
</div>


```{r}
leaflet(chi.poly) %>%
  addPolygons(stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5) %>%
  addTiles() #adds a map tile, the default is OpenStreetMap
```

<div style="text-align:justify">
Podemos agredar color usando el paquete RColorBrewer
</div>

```{r}
qpal<-colorQuantile("OrRd", chi.poly@data$violent, n=9) 

leaflet(chi.poly) %>%
  addPolygons(stroke = FALSE, fillOpacity = .8, smoothFactor = 0.2, color = ~qpal(violent)
  ) %>%
  addTiles()
```

<div style="text-align:justify">
La función colorQuantile del paquete **leaflet** mapea los valores de los datos a colores siguiendo una paleta. En este caso, he especificado una paleta de Naranjas y Rojos, para más paletas puede acceder al archivo de ayuda de RColorBrewer:? **RColorBrewer**.
</div>

# 4 Econometría espacial en R

<div style="text-align:justify">
Cuando se trata del espacio, uno debe tener en cuenta la primera ley de geografía de Tobler "Todo está relacionado con todo lo demás, pero las cosas cercanas están más relacionadas que las que están muy separadas" (Tobler (1979)). 
</div>

<div style="text-align:justify">
En esta sección nos centraremos en la especificación de la dependencia espacial, en las pruebas de especificación para detectar la dependencia espacial en los modelos de regresión y en los modelos de regresión básicos que incorporan la dependencia espacial. Ilustraremos esto utilizando los datos en el archivo de forma cargado en la sección anterior.
</div>

## Mínimos cuadrados ordinales (OLS)

<div style="text-align:justify">
El enfoque tradicional durante muchos años ha sido ignorar la dependencia espacial de los datos y simplemente ejecutar una regresión OLS.
</div>

 $y=Xβ+ϵ$

<div style="text-align:justify">
En R esto se logra con la función $lm$, por ejemplo:
</div>

```{r, echo=TRUE}
chi.ols<-lm(violent~est_fcs_rt+bls_unemp, data=chi.poly@data)
```

<div style="text-align:justify">
He especificado el "modelo" como $violento$ ~ est_fcs_rt + bls_unemp  donde la variable dependiente es violento, **est_fcs_rt** y **bls_unemp** son las variables explicativas. También he especificado el conjunto de datos que son los datos de la ranura de nuestro archivo shapefile. Tenga en cuenta que para acceder a este espacio utilizo el símbolo @. Esta línea no devuelve nada porque hemos creado un objeto lm que llamé chi.ols. Para ver los resultados, utilizamos la función de **summary()**.
</div>

```{r}
summary(chi.ols) %>% tidy() %>%
  rename("Terminos" = "term",
         "Coeficientes"= "estimate") %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Modelo violento ~ est_fcs_rt + bls_unemp" = 5))
```

<div style="text-align:justify">
El problema de ignorar la estructura espacial de los datos implica que las estimaciones de OLS en el modelo no espacial pueden ser sesgadas, inconsistentes o ineficientes, dependiendo de cuál sea la verdadera dependencia subyacente (para más información, ver Anselin y Bera (1998)).
</div>

## 4.2 Modelado de la dependencia espacial

<div style="text-align:justify">
Ahora echamos un vistazo más de cerca a la dependencia espacial, o para ser más precisos sobre su autocorrelación espacial de expresión más débil. La autocorrelación espacial mide el grado en que un fenómeno de interés se correlaciona consigo mismo en el espacio (Cliff y Ord (1973)). En otras palabras, valores similares aparecen cerca uno del otro, o agrupados, en el espacio (autocorrelación espacial positiva) o los valores vecinos son diferentes (autocorrelación espacial negativa). La autocorrelación espacial nula indica que el patrón espacial es aleatorio. Siguiendo a Anselin y Bera (1998) podemos expresar la existencia de autocorrelación espacial con la siguiente condición de momento:
</div>

$Cov(yi,yj)≠0fori≠j$

<div style="text-align:justify">
donde $ yi $ y $ yj $ son observaciones en una variable aleatoria en las ubicaciones i y j. El problema aquí es que necesitamos estimar los términos de covarianza de $ N $ por $ N $ directamente para las observaciones de $ N $. Para superar este problema, imponemos restricciones a la naturaleza de las interacciones. Un tipo de restricción es definir para cada punto de datos un "conjunto de vecindad" relevante. En la econometría espacial, esto se operacionaliza a través de la matriz de ponderaciones espaciales. La matriz generalmente denotada por $ W $ es un $ N $ por $ N $ matriz positiva y simétrica que denota por cada observación (fila) aquellas ubicaciones (columnas) que pertenecen a su conjunto de vecindarios como elementos distintos de cero (Anselin y Bera (1998), Arbia (2014)), el elemento típico es entonces:
</div>

[wij]={10ifj∈N(i)o.w

<div style="text-align:justify">
$ N (i) $ es el conjunto de vecinos de la ubicación j. Por convención, los elementos diagonales se establecen en cero, es decir, $ wii = 0 $. Para ayudar con la interpretación, la matriz a menudo está estandarizada por filas, de modo que los elementos de una fila dada se suman a una.
</div>

<div style="text-align:justify">
La especificación del conjunto vecino es bastante arbitraria y hay una amplia gama de sugerencias en la literatura. Una forma popular es usar uno de los dos criterios siguientes:
</div>

+ Criterio de torre: dos unidades están cerca una de la otra si comparten un lado
+ Criterio reina: dos unidades están cerca si comparten un lado o una arista.


<div style="text-align:justify">
Otro enfoque utilizado es denotar dos observaciones como vecinas si están dentro de una cierta distancia, es decir, j∈N (j) si dij <dmax donde d es la distancia entre la ubicación i y j.
</div>

<div style="text-align:justify">
Aquí nos centraremos en usar el criterio de reina y alentamos al lector a experimentar con el criterio de torre. En R para obtener la matriz de pesos, utilizamos dos funciones. En el primer paso usamos **poly2nb** que construye una lista de vecinos, si se especifica la opción queen = TRUE, se construirá utilizando el criterio queen. Si se especifica FALSO, se utilizarán los criterios de torre. El siguiente paso es complementar la lista de vecinos con los pesos espaciales. La opción fila W estandariza la matriz.
</div>


```{r}
list.queen<-poly2nb(chi.poly, queen=TRUE)
W<-nb2listw(list.queen, style="W", zero.policy=TRUE)
W
```

<div style="text-align:justify">
Podemos gráficar la distribución link con la usual función **plot()**
</div>

```{r}
plot(W,coordinates(chi.poly), main= "Distribución link con pesos Reina")
```

<div style="text-align:justify">
Para obtener la matriz de peso basada en distancias, usamos dos funciones: coordenadas que recuperarán las coordenadas centroides de los polígonos de las segmentos censales y datos cercanos que identificarán vecinos entre dos distancias en kilómetros medidos usando la distancia euclidiana. Por ejemplo, para encontrar vecinos dentro de 1 kilómetro hacemos:
</div>


```{r, echo=TRUE}
coords<-coordinates(chi.poly)
W_dist<-dnearneigh(coords,0,1,longlat = FALSE)
```

<div style="text-align:justify">
Le animo a comparar las distribuciones de enlaces para estas tres formas de definir vecinos.
</div>

## 4.2.1 Modelos espaciales autorregresivo (SAR) 

<div style="text-align:justify">
La dependencia del rezago espacial en la definición de regresión puede modelarse de manera similar a un proceso autorregresivo en series de tiempo. Formalmente,
</div>

$y=ρWy+Xβ+ϵ$

<div style="text-align:justify">
La presencia del término Wy induce una correlación distinta de cero con el término de error, similar a la presencia de una variable endógena, pero diferente del contexto de series de tiempo. Contrariamente a las series de tiempo, $[Wy]i$ siempre está correlacionado con $ϵi$ independientemente de la estructura de los errores. Esto implica que las estimaciones de OLS en el modelo no espacial serán sesgadas e inconsistentes. (Anselin y Bera (1998))
</div>

## 4.2.2 Modelos errores espaciales (SEM)

<div style="text-align:justify">
Otra forma de modelar la autocorrelación espacial en un modelo de regresión es especificar el proceso autorregresivo en el término de error:
</div>

$y=Xβ+ϵ$

con

$ϵ=λWϵ+u$

<div style="text-align:justify">
Si esta es la forma "verdadera" de dependencia espacial, las estimaciones de OLS serán insesgadas pero ineficientes.
</div>

## 4.3 Pruebas de autocorrelación Espacial

<div style="text-align:justify">
Existen múltiples pruebas para probar la presencia de autocorrelación espacial. </div>

<div style="text-align:justify">
En esta nota, nos enfocamos en un conjunto restringido: la prueba de Moran I y las pruebas de multiplicador de la Lagrange.
</div>


## 4.3.1 Prueba I de Moran

<div style="text-align:justify">
La prueba I de Moran se desarrolló originalmente como un análogo bidimensional de la prueba de Durbin-Watson
</div>

$I=(e′Wee′e)$

<div style="text-align:justify">
donde $e=y−Xβ$ es un vector de residuos OLS $β=(X′X)−1X′y$, W es la matriz de pesos espaciales estandarizadas de las filas. (Para más detalles ver Anselin y Bera (1998))
</div>

<div style="text-align:justify">
Para realizar una prueba de Moran en nuestros datos, necesitamos dos entradas, un objeto de regresión lm (estimado en la sección OLS) y la matriz de peso espacial
</div>

```{r}
moran.lm<-lm.morantest(chi.ols, W, alternative="two.sided")
moran.lm %>% tidy() %>% 
  rename("Observado_Moran"="estimate1",
         "Expectativa"="estimate2",
         "Varianza"="estimate3") %>%
  dplyr::select(-method,-alternative) %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Global Moran I con regresión residuos" = 5))
```

<div style="text-align:justify">
El cálculo de la estadística es relativo a una elección dada de los pesos espaciales W. Las diferentes especificaciones de la matriz de pesos darán resultados diferentes. Animo al lector a probar esto con el criterio de torre.
</div>

##  4.3.2 Prueba Multiplicador de Lagrange

<div style="text-align:justify">
Una buena característica de la prueba I de Moran es que tengo un alto poder frente a una amplia gama de alternativas (Anselin y Bera (1998)). Sin embargo, no nos guía en la selección de modelos alternativos. Por otro lado, la prueba del multiplicador de Lagrange especifica la hipótesis alternativa que nos ayudará con la tarea. Las pruebas de LM para la dependencia espacial se incluyen en la función **lm.LMtests** e incluyen como alternativas la presencia de un retraso espacial y la presencia de un retraso espacial en el término de error. Ambas pruebas, así como sus formas robustas, están incluidas en la función lm.LMtests(). Para llamarlos usamos la opción **test = "all"**. Nuevamente, un objeto de regresión y un objeto espacial listw deben pasarse como argumentos:
</div>


```{r}
LM<-lm.LMtests(chi.ols, W, test="all")
LM$LMerr %>% tidy() %>% 
  dplyr::select(-method) %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Diagnostico de dependencia espacial LMerr" = 3))
LM$LMlag%>% tidy() %>% 
  dplyr::select(-method) %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Diagnostico de dependencia espacial LMlag" = 3))
LM$RLMerr%>% tidy() %>% 
  dplyr::select(-method) %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Diagnostico de dependencia espacial RLMerr" = 3))
LM$RLMlag%>% tidy() %>% 
  dplyr::select(-method) %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Diagnostico de dependencia espacial RLMlag" = 3))
LM$SARMA%>% tidy() %>% 
  dplyr::select(-method) %>% 
    knitr::kable("html",format.args = list(decimal.mark = ',', big.mark = ".")) %>%
    kableExtra::kable_styling(c("striped"), full_width = F, position = "center")  %>%  
    kableExtra::add_header_above(c("Diagnostico de dependencia espacial SARMA" = 3))
```

<div style="text-align:justify">
Dado que LMerr y LMlag son estadísticamente significativos diferentes de cero, debemos analizar sus contrapartes robustas. Estas contrapartes robustas son realmente robustas a la presencia del otro "tipo" de autocorrelación. La versión robusta de las pruebas sugiere que el rezago del modelo es la alternativa más probable.
</div>

## 4.4 Ejecución de regresiones espaciales

### 4.4.1 Modelos SAR 

<div style="text-align:justify">
La estimación del modelo SAR puede abordar en:
</div>

```{r}
sar.chi<-lagsarlm(violent~est_fcs_rt+bls_unemp, data=chi.poly@data, W)
summary(sar.chi)
```

<div style="text-align:justify">
Otro camino es usar $2SLS$ usando la función stsls. Le dejo esto al lector para que pueda comparar los resultados con el enfoque MLE. La función es:
</div>

```{r}
sar2sls.chi<-stsls(violent~est_fcs_rt+bls_unemp, data=chi.poly@data, W)
summary(sar2sls.chi)
```

<div style="text-align:justify">
Luego podemos comparar los residuos de la regresión de OLS con los residuos del modelo espacial autorregresivo. Para acceder a los residuos para el modelo OLS y el modelo SAR simplemente hacemos
</div>

```{r}
chi.poly@data$chi.ols.res<-resid(chi.ols) #residuals ols
chi.poly@data$chi.sar.res<-resid(sar.chi) #residual sar
```

<div style="text-align:justify">
En este paso, crearé una nueva variable en la porción de datos del archivo de shapefile que ayudará a trazar los residuos. Para trazar los residuos, uso la función spplot en el paquete **spdep**. Los argumentos son el archivo de forma, la variable que queremos trazar, el número de saltos y los colores que vamos a utilizar. Para especificar los colores, utilizamos la paleta Rojo y Azul (RdBu) del paquete RColorBrewer.
</div>


```{r}
spplot(chi.poly,"chi.ols.res", at=seq(min(chi.poly@data$chi.ols.res,na.rm=TRUE),max(chi.poly@data$chi.ols.res,na.rm=TRUE),length=12),col.regions=rev(brewer.pal(11,"RdBu")))
```

```{r}
spplot(chi.poly,"chi.sar.res",at=seq(min(chi.poly@data$chi.sar.res,na.rm=TRUE),max(chi.poly@data$chi.sar,na.rm=TRUE), length=12), col.regions=rev(brewer.pal(11,"RdBu")))
```

### 4.4.1.1 Efectos Marginales

<div style="text-align:justify">
Tenga en cuenta que la presencia de la matriz de pesos espaciales hace que los efectos marginales sean más ricos y un poco más complicados que en el modelo OLS "tradicional". Tendremos tres medidas de impacto sugeridas por Pace y LeSage (2009) y se realiza en R con los impactos de la función
</div>

```{r}
impacts(sar.chi, listw=W)
```

<div style="text-align:justify">
El impacto directo se refiere al impacto total promedio de un cambio de una variable independiente en el dependiente de cada observación, es decir, $ n − 1∑ni = 1∂E (yi) ∂Xi $, el impacto indirecto que es la suma de impacto producido en una sola observación por todas las demás observaciones y el impacto de una observación en todas las demás. El total es la suma de los dos.
</div>


### 4.4.2 SEM Models

<div style="text-align:justify">
Por otro lado, si queremos estimar el modelo de error espacial, tenemos dos enfoques nuevamente. Primero, podemos usar la máxima verosimilitud como antes, con la función **errorsarlm**
</div>


```{r}
errorsalm.chi<-errorsarlm(violent~est_fcs_rt+bls_unemp, data=chi.poly@data, W)
summary(errorsalm.chi)
```

<div style="text-align:justify">
El mismo gráfico para los residuos SEM se puede hacer como antes y se deja para el lector. Un segundo enfoque es utilizar mínimos cuadrados generalizados factibles (GLS) con la función GMerrorsar. La función es:
</div>


```{r}
fgls.chi<-GMerrorsar(violent~est_fcs_rt+bls_unemp, data=chi.poly@data, W)
summary(fgls.chi)
```

<div style="text-align:justify">
Finalmente, si observamos la probabilidad para el modelo SAR y el modelo SEM, vemos que alcanzamos un valor más bajo para el modelo SAR que fue el modelo favorecido por LMtests. El gráfico de residuos presentado anteriormente todavía muestra cierta presencia de autocorrelación espacial. Es muy probable que se especifique un modelo más completo. La literatura se ha expandido a modelos más complejos. Se alienta al lector a leer Anselin y Bera (1998), Arbia (2014) y Pace and LeSage (2009) para obtener introducciones más detalladas y completas sobre la Econometría espacial.
</div>


# Referencias

<div style="text-align:justify">
Anselin, Luc. 2003. “An Introduction to Spatial Regression Analysis in R.” Available at: [Aquí](Https://geodacenter.asu.edu/drupal_files/spdepintro.pdf.)


Anselin, Luc, and Anil K Bera. 1998. “Spatial Dependence in Linear Regression Models with an Introduction to Spatial Econometrics.” Statistics Textbooks and Monographs 155. MARCEL DEKKER AG: 237–90.

Arbia, Giuseppe. 2014. A Primer for Spatial Econometrics: With Applications in R. Palgrave Macmillan.

Bivand, Roger S, Edzer J Pebesma, and Virgilio Gomez-Rubio. 2008. Applied Spatial Data Analysis with R. Springer. Springer.

Bivand, Roger, and Nicholas Lewin-Koh. 2016. Maptools: Tools for Reading and Handling Spatial Objects. [Aquí](https://CRAN.R-project.org/package=maptools.)

Bivand, Roger, and Gianfranco Piras. 2015. “Comparing Implementations of Estimation Methods for Spatial Econometrics.” Journal of Statistical Software 63 (18): 1–36. [Aquí](http://www.jstatsoft.org/v63/i18/.)

Bivand, Roger, Jan Hauke, and Tomasz Kossowski. 2013. “Computing the Jacobian in Gaussian Spatial Autoregressive Models: An Illustrated Comparison of Available Methods.” Geographical Analysis 45 (2): 150–79. [Aquí](http://www.jstatsoft.org/v63/i18/.)

Cheng, Joe, and Yihui Xie. 2015. Leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library. [Aquí](http://rstudio.github.io/leaflet/.)

Cliff, Andrew David, and J Keith Ord. 1973. Spatial Autocorrelation. Vol. 5. Pion London.

ESRI, Environmental Systems Research Institute. 1998. “ESRI Shapefile Technical Description.” [Disponible](Https://www.esri.com/library/whitepapers/pdfs/shapefile.pdf.)

Neuwirth, Erich. 2014. RColorBrewer: ColorBrewer Palettes. [Aquí](https://CRAN.R-project.org/package=RColorBrewer.)

Pace, R Kelley, and JP LeSage. 2009. “Introduction to Spatial Econometrics.” Boca Raton, FL: Chapman &Hall/CRC.

Tobler, WR. 1979. “Cellular Geography.” In Philosophy in Geography, 379–86. Springer.

Wickham, Hadley. 2015. R Packages. “O’Reilly Media, Inc.”
</div>
